<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>í—ˆí”„ë§Œ íŠ¸ë¦¬ ì‹œë®¬ë ˆì´í„°</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    .node-list { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; }
    .node { border: 1px solid #ccc; padding: 10px; cursor: pointer; border-radius: 5px; background: #f9f9f9; user-select:none; }
    .node.selected { background-color: #b3e5fc; }
    #tree-log { background: #eee; padding: 10px; white-space: pre-wrap; margin-top: 20px; border-radius: 5px; max-height: 150px; overflow-y: auto; }
    svg { border: 1px solid #ccc; background: #fff; margin-top: 20px; width: 100%; height: 400px; }
    table { border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #ccc; padding: 5px 10px; text-align: center; }
    input.freq-input { width: 50px; text-align: center; }
    button { margin: 5px 10px 5px 0; }
  </style>
</head>
<body>
  <h1>ğŸŒ² í—ˆí”„ë§Œ íŠ¸ë¦¬ ì‹œë®¬ë ˆì´í„°</h1>
  <p>ëœë¤ ë¬¸ìì—´ì„ ë³´ê³  ë¬¸ì ë¹ˆë„ë¥¼ ì§ì ‘ ì…ë ¥í•˜ê³  ê²€ì¦í•œ í›„ ë…¸ë“œ ë³‘í•©ì„ ì‹œì‘í•˜ì„¸ìš”.</p>

  <div><strong>ëœë¤ ë¬¸ìì—´:</strong> <span id="random-string"></span></div>

  <h3>ğŸ“Š ë¬¸ì ë¹ˆë„ ì…ë ¥ ë° ê²€ì¦</h3>
  <table id="freq-table">
    <thead>
      <tr><th>ë¬¸ì</th><th>ë¹ˆë„ ì…ë ¥</th></tr>
    </thead>
    <tbody></tbody>
  </table>
  <button onclick="checkFrequencies()">ë¹ˆë„ìˆ˜ ê²€ì¦ ë° ë…¸ë“œ ìƒì„±</button>

  <h3>ğŸŸ¢ ë³‘í•© ê°€ëŠ¥í•œ ë…¸ë“œ</h3>
  <div id="node-container" class="node-list"></div>

  <button onclick="submitTree()">ì œì¶œ</button>
  <button onclick="init()">ì¬ì‹œì‘</button>

  <h3>ğŸ§¾ ë³‘í•© ê¸°ë¡</h3>
  <div id="tree-log"></div>

  <h3>ğŸŒ íŠ¸ë¦¬ ì‹œê°í™”</h3>
  <svg id="tree-svg"></svg>

  <h3>ğŸ“¦ í—ˆí”„ë§Œ ì½”ë“œ ë° ì••ì¶•ë¥ </h3>
  <pre id="result-output"></pre>

  <script>
    const charset = "ABCDE";
    let nodes = [];
    let selectedNodes = [];
    let treeLog = [];
    let originalString = "";
    let freq = {};
    let trueTree = null;

    function generateRandomString(length = 20) {
      let result = "";
      for (let i = 0; i < length; i++) {
        result += charset[Math.floor(Math.random() * charset.length)];
      }
      return result;
    }

    function getFrequencies(str) {
      const freq = {};
      for (const ch of str) freq[ch] = (freq[ch] || 0) + 1;
      return freq;
    }

    function renderFreqTable(freq) {
      const tbody = document.querySelector("#freq-table tbody");
      tbody.innerHTML = "";
      Object.entries(freq).forEach(([char]) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${char}</td>
          <td><input type="number" min="0" class="freq-input" id="freq-${char}" value="0" /></td>
        `;
        tbody.appendChild(tr);
      });
    }

    function checkFrequencies() {
      let correct = true;
      for (const char in freq) {
        const val = parseInt(document.getElementById(`freq-${char}`).value, 10);
        if (val !== freq[char]) {
          correct = false;
          break;
        }
      }
      if (!correct) {
        alert("ë¹ˆë„ìˆ˜ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì…ë ¥í•´ì£¼ì„¸ìš”.");
        return;
      }
      alert("ë¹ˆë„ìˆ˜ê°€ ì •í™•í•©ë‹ˆë‹¤! ë…¸ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.");
      nodes = createInitialNodes(freq);
      treeLog = [];
      selectedNodes = [];
      document.getElementById("tree-log").textContent = "";
      document.getElementById("result-output").textContent = "";
      document.getElementById("tree-svg").innerHTML = "";
      renderNodes();
    }

    function createInitialNodes(freq) {
      return Object.entries(freq).map(([char, count]) => ({
        label: char,
        count,
        id: char + Math.random().toString(36).substr(2, 5),
        children: [],
        x: 0,
        y: 0
      }));
    }

    function renderNodes() {
      const container = document.getElementById("node-container");
      container.innerHTML = "";
      nodes.forEach(node => {
        const div = document.createElement("div");
        div.className = "node" + (selectedNodes.includes(node) ? " selected" : "");
        div.textContent = `${node.label} (${node.count})`;
        div.onclick = () => selectNode(node);
        container.appendChild(div);
      });
    }

    function selectNode(node) {
      if (selectedNodes.includes(node)) {
        selectedNodes = selectedNodes.filter(n => n !== node);
      } else if (selectedNodes.length < 2) {
        selectedNodes.push(node);
      }
      if (selectedNodes.length === 2) {
        mergeSelectedNodes();
      }
      renderNodes();
    }

    function mergeSelectedNodes() {
      const [a, b] = selectedNodes;
      const newNode = {
        label: a.label + b.label,
        count: a.count + b.count,
        id: a.id + b.id,
        children: [a, b]
      };
      nodes = nodes.filter(n => n !== a && n !== b);
      nodes.push(newNode);
      treeLog.push(`ë³‘í•©: ${a.label}(${a.count}) + ${b.label}(${b.count}) â†’ ${newNode.label}(${newNode.count})`);
      selectedNodes = [];
      renderNodes();
      renderLog();
      drawTree(newNode);
    }

    function renderLog() {
      document.getElementById("tree-log").textContent = treeLog.join("\n");
    }

    let pq = Object.entries(freq).map(([char, count], index) => ({ label: char, count, children: [], order: index }));
while (pq.length > 1) {
  pq.sort((a, b) => {
    if (a.count !== b.count) return a.count - b.count;
    return a.order - b.order; // ë¹ˆë„ ê°™ì„ ê²½ìš°, ì…ë ¥ ìˆœì„œ ê¸°ì¤€
  });
  const a = pq.shift();
  const b = pq.shift();
  pq.push({
    label: a.label + b.label,
    count: a.count + b.count,
    children: [a, b],
    order: Math.min(a.order, b.order) // ìƒˆ ë…¸ë“œë„ ë‚®ì€ ìˆœì„œ ìœ ì§€
  });
}
    function getCodes(node, path = "", result = {}) {
      if (!node.children || node.children.length === 0) {
        result[node.label] = path;
      } else {
        getCodes(node.children[0], path + "0", result);
        getCodes(node.children[1], path + "1", result);
      }
      return result;
    }

    function getEncodedLength(codes, str) {
      return str.split("").reduce((sum, ch) => sum + (codes[ch]?.length || 0), 0);
    }

    function submitTree() {
      if (nodes.length !== 1) {
        alert("ë³‘í•©ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
        return;
      }
      const userTree = nodes[0];
      const userCodes = getCodes(userTree);
      const correctCodes = getCodes(trueTree);

      let resultText = "[ğŸ“¦ í—ˆí”„ë§Œ ì½”ë“œ]\n";
      for (const ch of Object.keys(correctCodes).sort()) {
        resultText += `${ch}: ë‹¹ì‹ =${userCodes[ch] || "ì—†ìŒ"}, ì •ë‹µ=${correctCodes[ch]}\n`;
      }

      const originalBits = originalString.length * 8;
      const userBits = getEncodedLength(userCodes, originalString);
      const compressRate = ((userBits / originalBits) * 100).toFixed(2);

      resultText += `\nì›ë³¸ ë¹„íŠ¸ ìˆ˜: ${originalBits}\nì••ì¶• í›„ ë¹„íŠ¸ ìˆ˜: ${userBits}\nì••ì¶•ë¥ : ${compressRate}%`;

      document.getElementById("result-output").textContent = resultText;
    }

    // íŠ¸ë¦¬ ì¢Œí‘œ í• ë‹¹ ë° SVG ê·¸ë¦¬ê¸°
    function drawTree(root) {
      const svg = document.getElementById("tree-svg");
      svg.innerHTML = "";

      let index = 0;
      function setPosition(node, depth) {
        if (!node.children.length) {
          node.x = 100 + index * 80;
          node.y = depth * 80 + 20;
          index++;
        } else {
          setPosition(node.children[0], depth + 1);
          setPosition(node.children[1], depth + 1);
          node.x = (node.children[0].x + node.children[1].x) / 2;
          node.y = depth * 80 + 20;
        }
      }
      setPosition(root, 0);

      function drawNode(node) {
        if (node.children.length) {
          node.children.forEach(child => {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", node.x);
            line.setAttribute("y1", node.y + 15);
            line.setAttribute("x2", child.x);
            line.setAttribute("y2", child.y - 15);
            line.setAttribute("stroke", "black");
            svg.appendChild(line);
            drawNode(child);
          });
        }
        // ë…¸ë“œ ì›ê³¼ í…ìŠ¤íŠ¸
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", node.x);
        circle.setAttribute("cy", node.y);
        circle.setAttribute("r", 15);
        circle.setAttribute("fill", "#90caf9");
        circle.setAttribute("stroke", "#42a5f5");
        svg.appendChild(circle);

        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", node.x);
        text.setAttribute("y", node.y + 5);
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("font-size", "12");
        text.setAttribute("font-weight", "bold");

        // ë¶€ëª¨ë…¸ë“œëŠ” ìˆ«ìë§Œ, ìì‹ë…¸ë“œëŠ” ë¬¸ìë§Œ ë³´ì—¬ì£¼ê¸°
        if (node.children.length > 0) {
          // ë¶€ëª¨ë…¸ë“œ: ìˆ«ìë§Œ í‘œì‹œ
          text.textContent = `${node.count}`;
        } else {
          // ë¦¬í”„ë…¸ë“œ(ìì‹ë…¸ë“œ): ë¬¸ìë§Œ í‘œì‹œ
          text.textContent = `${node.label}`;
        }

        svg.appendChild(text);
      }
      drawNode(root);
    }

    // ì´ˆê¸°í™” (ì¬ì‹œì‘ í¬í•¨)
    function init() {
      originalString = generateRandomString();
      document.getElementById("random-string").textContent = originalString;
      freq = getFrequencies(originalString);
      renderFreqTable(freq);
      nodes = [];
      selectedNodes = [];
      treeLog = [];
      trueTree = buildHuffmanTree(freq);
      document.getElementById("node-container").innerHTML = "";
      document.getElementById("tree-log").textContent = "";
      document.getElementById("tree-svg").innerHTML = "";
      document.getElementById("result-output").textContent = "";
    }

    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
    window.onload = init;
  </script>
</body>
</html>
